import * as vscode from 'vscode';

/**
 * Message generated by a plugin
 */
export interface PluginMessage {
  userPrompt: string;
  includeContext: boolean;
  text?: string; // Optional text to append to the LLM reply
}

export interface EnqueueMessageOptions {
  priority?: boolean;
}

/**
 * Context passed to plugins when generating messages
 */
export interface PluginContext {
  editor: vscode.TextEditor | undefined;
  panel: vscode.WebviewPanel;
  lastEditedFiles: string[];
  chatHistory: any[];
  getRelativePath: (absPath: string) => string;
  getLinesAround: (doc: vscode.TextDocument, centerLine: number, radius: number) => { start: number; end: number; text: string };
  enqueueMessage: (message: string, options?: EnqueueMessageOptions) => void;
}

/**
 * Base interface for all plugins
 */
export interface IPlugin {
  /**
   * Unique identifier for the plugin
   */
  readonly id: string;

  /**
   * Human-readable name of the plugin
   */
  readonly name: string;

  /**
   * Whether this plugin is currently enabled
   */
  isEnabled(config: vscode.WorkspaceConfiguration): boolean;

  /**
   * Get the default weight for this plugin (higher = more likely to trigger)
   * Default weight is 1.0 if not specified
   * Can be overridden by user configuration
   */
  getWeight?(config: vscode.WorkspaceConfiguration): number;

  /**
   * Whether this plugin should trigger in the current context
   * Used by the periodic trigger to filter out plugins that shouldn't run
   * Returns true by default if not implemented
   * Can be async to perform checks like connectivity
   */
  shouldTrigger?(context: PluginContext): boolean | Promise<boolean>;

  /**
   * Generate a message for the LLM based on current context
   * Returns null if the plugin cannot generate a message in the current state
   */
  generateMessage(context: PluginContext): Promise<PluginMessage | null>;

  /**
   * Called after the LLM generates a response to this plugin's message
   * Allows the plugin to store state for future invocations
   */
  onResponse?(response: string): void;

  /**
   * Called when the plugin should activate (e.g., register event listeners)
   */
  activate?(context: PluginContext): void;

  /**
   * Called when the plugin should deactivate
   */
  deactivate?(): void;
}
